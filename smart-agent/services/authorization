var log = require("log");
log.setLevel("info");
var proxyfactoryModule =  require("/smart-agent/services/proxyfactory");
var constants = require("/smart-agent/common/constants");
var device = require("device");
var util = require("smart-agent/common/util");
var document = require("document");
const masterNodeDescriptor = require("smart-agent/tests/swagger2/master-descriptor").desc;
const MASTER = "master";
var directoryModule = require("./directory");
const VISITOR_TOKEN_SCHEMA = "visitor_token";
var config = require("smart-agent/setup/config");

/**
 * Handles the authentication of remote requests
 * @class Authorization
 * @constructor
 */
function Authorization() {

    this.proxyFactory = new proxyfactoryModule.ProxyFactory();
}

/**
 * @method authenticate
 * @param {Object} credentials: the token to authenticate
 * @return {String} if the token is valid returns success else throws an error
 * @throw {Error}
 */
Authorization.prototype.authenticate = function(credentials) {
    
    //if not master
    var directory = new directoryModule.Directory();
    if (directory.config != MASTER) {
        if (credentials.token) {
            return this.authenticateFromMaster(credentials).response.result;  
        }

        throw {
            errorCode: constants.INVALID_AUTHENTICATION_MODE,
            errorCode: "The provided credential object does not contain a token"
        }
    }
};

/**
 * Convey a token that was received in the "x-auhtorization" header to the master agent in order to
 * authenticate it. If the master agent is able to authenticate the corresponding device as part of  
 * the collaboration boundary, add the device locally and generate a token
 * @method authenticateFromMaster
 * @param {Object} credentials: the token to authenticate
 * @return {String} if the token is valid returns success else throws an INVALID_TOKEN error
 */
Authorization.prototype.authenticateFromMaster = function(credentials) {

    log.info("Authorization.authenticateFromMaster credentials: " + JSON.stringify(credentials));
    var config = {

        "masterAgent": {
            "username": "username",
            "password": "password",
            "token": credentials.token
        },
        "masterNodeDescriptor": masterNodeDescriptor
    };

    var masterAgent = this.proxyFactory.getMasterAgentProxy(config);
    log.info("Authorization.authenticateFromMaster master agent: " + JSON.stringify(masterAgent));
    return masterAgent.getVerifyToken();
};

/**
 * Get the credentials needed to invoke remote services on a third party node
 * First checks if credentials are available locally, if not, should ask for credentials agains the 3rd party
 * by sending credentials used to authenticate at master. The latter will provide temporary credentials to the 
 * caller
 */
Authorization.prototype.visitorToken = function(dto) {

    if (!dto || !dto.id) {
        throw {
            errorCode:'Missing_Parameter',
            errorDetail:'dto.id should be defined'
        };
    }

    var directory = new directoryModule.Directory();
    if (directory.config.role != MASTER) {

        var token = this._getValidTokenFromDoc();
        if(token){
            return token;
        }
        log.info("No valid token");
        this._deleteExpiredToken();

        var masterProxy = this.proxyFactory.getMasterAgentProxy(directory.config);
        var res = masterProxy.getVisitorToken(dto).response.result;

        log.info("Storing new token");
        this._storeToken({visitorToken: res.visitorToken}, res.tokenExpDate);
        return res;
    }

    log.info("Authorization.visitorToken node is a master");
    var deviceReq = {

        query: 'requesterId = "' + dto.id + '"',
        fields: "visitorId"
    };

    if (!this._deviceExists(deviceReq)) {

        log.error("Device does not exist");
        var name = util.randomId();
        var password = util.randomId();
        var dev = {

            "name": name,
            "password": password
        };

        log.info("Device: \n" + JSON.stringify(dev));
        var newVisitor = device.create(dev);
        var newVisitorId = newVisitor.result.device.id;
        var fields = {

            "visitorId": newVisitorId,
            "requesterId": dto.id,
            "tokensGenerated": 1,
            "meta.schema": VISITOR_TOKEN_SCHEMA
        };

        var token = device.generateToken(newVisitor.result.device.id).result.token;
        document.create(fields);
        return {"visitorToken": token, "tokenExpDate": this._getTokenExpDate(newVisitorId)};
    }else{

        log.info("Device exists");

        var docKey = document.query(deviceReq).result.documents[0].key;
        var tokensGenerated = ++document.get(docKey).result.tokensGenerated;
        var visitorId = document.get(docKey).result.visitorId;

        document.update({"key": docKey, "tokensGenerated": tokensGenerated, "meta.types": {"tokensGenerated": "numeric"}});
        var token = device.regenerateToken(visitorId).result.token;
        return {"visitorToken": token, "tokenExpDate": this._getTokenExpDate(visitorId)};
    }
};

/**
 * From the document, get the token's expiration date
 * @method _getTokenExpDate
 * @param {String} visitorId: the device's Id
 * @return {Date} The expiration date of the token
 */
Authorization.prototype._getTokenExpDate = function(visitorId) {

    var lastModifiedDate = document.query({query: 'visitorId ="' + visitorId + '"', fields: "lastModifiedDate"}).result.documents[0].lastModifiedDate;
    var expDate = new Date(lastModifiedDate);
    expDate = expDate.setMinutes(expDate.getMinutes() + config.tokenTTL);
    return util.toScriptrDataFormat(expDate);
};

/**
 * Return null if there's no document for the mentioned device to show that it does not exist
 * @method _deviceExists
 * @param {Obejct} deviceReq: filter that contains the conditions for the document search 
 * @return {Object} if the device doesn't exist returns null
 */
Authorization.prototype._deviceExists = function(deviceReq){
    //return document.query(deviceReq).result.documents[0];
    return false;
};

/**
 * Stores the recently generated token and its expiration date
 * @method _storeToken
 * @param {Object} credentials: the token to store
 * @param {date} tokenExpirationDate: the token's expiration date
 */
Authorization.prototype._storeToken = function(credentials, tokenExpirationDate) {

    document.save({visitorToken: credentials.visitorToken, tokenExpDate: tokenExpirationDate, "meta.types": {tokenExpDate: "date"}});
};

/**
 * Look for a valid token in the documents and returns one if it exists
 * @method _getValidTokenFromDoc
 * @return {String} if token exists returns it else it return null
 */
Authorization.prototype._getValidTokenFromDoc = function(){

    var date = new Date();
    date = util.toScriptrDataFormat(date);
    var validTokenDoc = document.query({query: 'tokenExpDate<date> >"' + date + '"', fields: "*"}).result.documents[0];
    if (validTokenDoc) {

        return validTokenDoc.visitorToken;
    }
    return;
};

/**
 * Get token if it has exceeded its expiration date and delete it
 * @method _deleteExpiredToken
 */
Authorization.prototype._deleteExpiredToken = function(){

    var date = new Date();
    date = util.toScriptrDataFormat(date);
    var expiredToken = document.query({query: 'tokenExpDate<date> <"' + date + '"', fields: "tokenExpDate"}).result.documents[0];
    if(expiredToken){
        log.info("Expired token found, deleting");
        document.delete(expiredToken.key);
    }
}